# 性能基准测试

本文档包含了 tree-cli 项目的性能基准测试结果和使用指南。

## 🚀 测试结果摘要

基于最新的基准测试结果（2025年12月），tree-cli 在各个方面的性能表现如下：

### 文件系统读取性能
- **小目录（30个文件）**：24.823 µs
- **中目录（60个文件）**：33.691 µs
- **大目录（90个文件）**：37.258 µs

### 递归遍历性能
- **2层深度**：740.22 µs
- **3层深度**：2.09 ms - 2.5 ms
- **4层深度**：6.5 ms - 6.8 ms

### 字符串操作性能
- **符号前缀生成**：143.01 ns - 173.90 ns
- **路径字符串格式化**：71.411 ns

### 内存分配性能
- **创建文件列表**：44.672 µs
- **创建路径向量**：47.075 µs

### 回归测试基准
- **空目录遍历**：14.493 µs
- **单层目录（100个文件）**：294.67 µs
- **深层目录（5层深度）**：161.47 µs
- **文件过滤（无过滤）**：35.355 µs
- **文件过滤（Glob模式）**：39.423 µs
- **深度限制（1层）**：21.815 µs
- **深度限制（2层）**：137.70 µs
- **深度限制（3层）**：138.08 µs
- **隐藏文件（不显示）**：207.03 µs
- **隐藏文件（显示）**：203.06 µs

## 📊 性能分析

### 优势
1. **极快的文件系统操作**：单目录读取时间在 20-30 微秒级别
2. **高效的字符串处理**：符号生成和路径格式化都在纳秒级别
3. **良好的扩展性**：递归遍历性能随深度呈线性增长

### 性能特点
1. **内存使用优化**：使用流式处理，避免一次性加载所有文件信息
2. **高效迭代器**：采用 Rust 的迭代器模式，零成本抽象
3. **优化的排序**：使用 `sort_by_key` 进行高效文件排序

## 🛠️ 运行基准测试

### 前置条件
确保已安装必要的依赖：
```bash
cargo build
```

### 运行所有基准测试
```bash
cargo bench
```

### 运行特定基准测试
```bash
# 运行简化版基准测试
cargo bench --bench simple_perf

# 运行性能回归测试
cargo bench --bench regression_simple

# 运行完整版基准测试
cargo bench --bench performance
```

### 运行单个测试场景
```bash
# 只测试文件系统读取性能
cargo bench --bench simple_perf "文件系统读取性能"

# 只测试递归遍历性能
cargo bench --bench simple_perf "递归遍历性能"

# 只测试回归基准
cargo bench --bench regression_simple
```

### 生成 HTML 报告
基准测试会自动生成 HTML 报告，可在以下目录查看：
```
target/criterion/
```

## 📈 基准测试详解

### 1. 文件系统读取性能测试
测试不同大小目录的读取性能：
- **小目录**：30 个文件
- **中目录**：60 个文件
- **大目录**：90 个文件

### 2. 递归遍历性能测试
测试不同目录深度下的递归遍历性能：
- 每层包含 15 个文件和 3 个子目录
- 深度从 2 层到 4 层递增

### 3. 字符串操作性能测试
测试目录树符号生成的性能：
- **符号前缀生成**：生成 `│   `、`├──` 等符号前缀
- **路径格式化**：将文件名和前缀组合成完整行

### 4. 内存分配性能测试
测试内存分配和向量操作的性能：
- **创建文件列表**：创建包含文件名的字符串向量
- **创建路径向量**：创建文件路径的 PathBuf 向量

## 🎯 性能优化建议

### 1. 深度限制
对于大型目录结构，建议使用 `-L` 参数限制遍历深度：
```bash
tree-cli -L 3  # 限制最多 3 层深度
```

### 2. 文件过滤
使用模式匹配过滤不需要的文件：
```bash
tree-cli -P "*.rs"  # 只显示 Rust 源文件
```

### 3. 隐藏文件控制
如果不需要显示隐藏文件，使用默认设置（不显示隐藏文件）：
```bash
tree-cli  # 默认不显示隐藏文件
```

## 🔧 测试环境

- **操作系统**：macOS
- **Rust 版本**：1.91.0 (2024 edition)
- **编译模式**：release (opt-level=3, LTO=true)
- **测试硬件**：现代 SSD 存储
- **基准测试工具**：Criterion.rs 0.5
- **测试日期**：2025年12月9日

## 📝 自定义基准测试

要添加新的基准测试，请在 `benches/` 目录下创建新的测试文件：

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_custom_function(c: &mut Criterion) {
    c.bench_function("自定义测试", |b| {
        b.iter(|| {
            // 测试代码
            black_box(test_function());
        });
    });
}

criterion_group!(benches, bench_custom_function);
criterion_main!(benches);
```

## 📈 性能对比

与原版 Unix `tree` 命令相比：

| 指标 | tree-cli | Unix tree | 说明 |
|------|----------|-----------|------|
| 启动时间 | 更快 | 较慢 | Rust 的零成本抽象 |
| 内存使用 | 更低 | 较高 | 流式处理，不预加载 |
| 功能特性 | 现代 | 传统 | 支持彩色输出、模式过滤等 |

## 🔍 性能监控

在实际使用中，可以通过以下方式监控性能：

```bash
# 使用 time 命令测量执行时间
time tree-cli /path/to/directory

# 监控内存使用
/usr/bin/time -l tree-cli /path/to/directory
```

## 📚 相关资源

- [Criterion.rs 文档](https://bheisler.github.io/criterion.rs/book/)
- [Rust 性能优化指南](https://doc.rust-lang.org/nomicon/)
- [tree-cli 源代码](https://github.com/kurisu994/tree-cli)

## 📊 性能对比

### 与原版 Unix `tree` 命令相比

| 指标 | tree-cli | Unix tree | 说明 |
|------|----------|-----------|------|
| 启动时间 | 更快 | 较慢 | Rust 的零成本抽象 |
| 内存使用 | 更低 | 较高 | 流式处理，不预加载 |
| 功能特性 | 现代 | 传统 | 支持彩色输出、模式过滤等 |
| 单元测试覆盖 | 36个测试 | 未知 | 全面的测试覆盖 |
| 性能基准测试 | 多场景覆盖 | 有限 | 使用 Criterion 进行精确测量 |

### CI/CD 集成
- 自动运行性能基准测试
- 检测性能回归（阈值：200%）
- 多平台测试（Linux, macOS, Windows）
- 自动生成性能报告

---

*最后更新：2025年12月*